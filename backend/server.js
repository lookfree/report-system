const express = require('express');
const cors = require('cors');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const fsPromises = require('fs').promises;
const { v4: uuidv4 } = require('uuid');
require('dotenv').config();

const { PrismaClient } = require('@prisma/client');
const UniversalWordParser = require('./utils/universalWordParser');
const ReportGenerator = require('./utils/reportGenerator');
const TaskScheduler = require('./utils/taskScheduler');
const htmlWordConverter = require('./utils/htmlWordConverter');
const VariableProcessor = require('./utils/variableProcessor');
const datasetConfig = require('./models/DatasetConfig');
const datasetService = require('./utils/datasetService');
const datasetStore = require('./models/DatasetStore');

const app = express();
const prisma = new PrismaClient();
const wordParser = new UniversalWordParser();
const reportGenerator = new ReportGenerator(prisma);
const taskScheduler = new TaskScheduler(prisma, reportGenerator);
const variableProcessor = new VariableProcessor(prisma);

// HTML reconstruction function
function reconstructHtmlFromSections(sections, title = '', originalHtml = '') {
  console.log('üîß Reconstructing HTML from sections...');
  console.log(`üìä Sections count: ${sections ? sections.length : 0}`);
  console.log(`üìÑ Title: ${title || 'No title'}`);
  console.log(`üî§ Original HTML length: ${originalHtml ? originalHtml.length : 0}`);
  
  // If we have original HTML, prefer that over section reconstruction
  if (originalHtml && originalHtml.length > 0) {
    console.log('‚úÖ Using original HTML content');
    return originalHtml;
  }
  
  let html = '';
  
  // Add title if provided
  if (title) {
    html += `<h1>${title}</h1>\n`;
  }
  
  // Process each section
  if (sections && Array.isArray(sections)) {
    for (let i = 0; i < sections.length; i++) {
      const section = sections[i];
      console.log(`üìÑ Processing section ${i}: ${section.title || 'Untitled'}`);
      
      // Try multiple possible content fields
      let sectionHtml = '';
      if (section.rawContent) {
        sectionHtml = section.rawContent;
        console.log(`  ‚úÖ Using rawContent (${sectionHtml.length} chars)`);
      } else if (section.originalHtml) {
        sectionHtml = section.originalHtml;
        console.log(`  ‚úÖ Using originalHtml (${sectionHtml.length} chars)`);
      } else if (section.content) {
        sectionHtml = section.content;
        console.log(`  ‚úÖ Using content (${sectionHtml.length} chars)`);
      } else if (section.html) {
        sectionHtml = section.html;
        console.log(`  ‚úÖ Using html (${sectionHtml.length} chars)`);
      } else if (section.contentPreview) {
        // Use content preview as fallback
        sectionHtml = `<p>${section.contentPreview}</p>`;
        console.log(`  ‚ö†Ô∏è Using contentPreview fallback (${sectionHtml.length} chars)`);
      } else {
        // Create section header at minimum
        if (section.title) {
          sectionHtml = `<h2>${section.title}</h2>`;
          console.log(`  ‚ö†Ô∏è Using title only (${sectionHtml.length} chars)`);
        }
      }
      
      html += sectionHtml;
    }
  }
  
  const resultLength = html.length;
  console.log(`üéØ Reconstruction result: ${resultLength} characters`);
  
  // If we still don't have much content, this indicates a data structure issue
  if (resultLength < 100) {
    console.warn('‚ö†Ô∏è Very short reconstruction result - possible data structure issue');
    console.log('Sample section structure:', sections && sections[0] ? JSON.stringify(sections[0], null, 2) : 'No sections');
  }
  
  return html;
}

// Middleware
app.use(cors());
app.use(express.json({ limit: '50mb' })); // Â¢ûÂä†JSONÂ§ßÂ∞èÈôêÂà∂
app.use(express.urlencoded({ extended: true, limit: '50mb' })); // Â¢ûÂä†URLÁºñÁ†ÅÂ§ßÂ∞èÈôêÂà∂

// Â¢ûÂä†ËØ∑Ê±ÇË∂ÖÊó∂Êó∂Èó¥
app.use((req, res, next) => {
  // ‰∏∫Ê®°Êùø‰∏ä‰º†ËÆæÁΩÆÊõ¥ÈïøÁöÑË∂ÖÊó∂Êó∂Èó¥
  if (req.path === '/api/templates/upload') {
    req.setTimeout(300000); // 5ÂàÜÈíüË∂ÖÊó∂
    res.setTimeout(300000);
  }
  next();
});

// Create upload directories
const createDirs = async () => {
  const dirs = [process.env.UPLOAD_DIR, process.env.REPORTS_DIR];
  for (const dir of dirs) {
    await fsPromises.mkdir(dir, { recursive: true });
  }
};

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: async (req, file, cb) => {
    await createDirs();
    cb(null, process.env.UPLOAD_DIR);
  },
  filename: (req, file, cb) => {
    const uniqueName = `${uuidv4()}_${file.originalname}`;
    cb(null, uniqueName);
  }
});

const upload = multer({
  storage,
  limits: {
    fileSize: 50 * 1024 * 1024, // 50MB Êñá‰ª∂Â§ßÂ∞èÈôêÂà∂
    fieldSize: 10 * 1024 * 1024  // 10MB Â≠óÊÆµÂ§ßÂ∞èÈôêÂà∂
  },
  fileFilter: (req, file, cb) => {
    // Â§ÑÁêÜÊñá‰ª∂ÂêçÁºñÁ†Å
    try {
      if (file.originalname) {
        // Á°Æ‰øùÊñá‰ª∂ÂêçÊòØÊ≠£Á°ÆÁöÑUTF-8ÁºñÁ†Å
        file.originalname = Buffer.from(file.originalname, 'latin1').toString('utf8');
      }
    } catch (error) {
      console.warn('File name encoding issue:', error);
    }
    
    const ext = path.extname(file.originalname).toLowerCase();
    if (ext === '.docx' || ext === '.doc') {
      cb(null, true);
    } else {
      cb(new Error('Only Word documents are allowed'));
    }
  }
});


// Routes

// Upload and parse template
app.post('/api/templates/upload', upload.single('template'), async (req, res) => {
  try {
    const { name } = req.body;
    const file = req.file;
    
    if (!file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }
    
    // Ê£ÄÊü•Êñá‰ª∂Ê†ºÂºèÔºàÈÄöËøáÊñá‰ª∂Â§¥È≠îÊï∞Âà§Êñ≠Ôºâ
    const fileBuffer = await fsPromises.readFile(file.path);
    const isRealDocx = fileBuffer[0] === 0x50 && fileBuffer[1] === 0x4B; // PK (ZIPÊ†ºÂºèÊ†áËØÜ)
    const isOldDoc = fileBuffer[0] === 0xD0 && fileBuffer[1] === 0xCF; // ÊóßÁâàdocÊ†ºÂºèÊ†áËØÜ
    
    if (isOldDoc) {
      // Âà†Èô§‰∏ä‰º†ÁöÑÊó†ÊïàÊñá‰ª∂
      await fsPromises.unlink(file.path).catch(console.error);
      return res.status(400).json({ 
        error: 'ÊñáÊ°£Ê†ºÂºèÈîôËØØÔºöÊ£ÄÊµãÂà∞ÊóßÁâàWordÊ†ºÂºè(.doc)ÊàñWPSÊñáÊ°£„ÄÇËØ∑‰ΩøÁî®Microsoft WordÂè¶Â≠ò‰∏∫.docxÊ†ºÂºèÔºàOffice Open XMLÊ†ºÂºèÔºâÔºåÊàñ‰ΩøÁî®WPS OfficeÂØºÂá∫‰∏∫Ê†áÂáÜ.docxÊ†ºÂºèÂêéÈáçÊñ∞‰∏ä‰º†„ÄÇ' 
      });
    }
    
    if (!isRealDocx) {
      // Âà†Èô§‰∏ä‰º†ÁöÑÊó†ÊïàÊñá‰ª∂
      await fsPromises.unlink(file.path).catch(console.error);
      return res.status(400).json({ 
        error: 'ÊñáÊ°£Ê†ºÂºèÈîôËØØÔºöÊñá‰ª∂‰∏çÊòØÊúâÊïàÁöÑ.docxÊ†ºÂºè„ÄÇËØ∑Á°Æ‰øù‰ΩøÁî®Microsoft Word 2007ÊàñÊõ¥Êñ∞ÁâàÊú¨‰øùÂ≠òÔºåÊàñ‰ªéWPSÂØºÂá∫‰∏∫Ê†áÂáÜ.docxÊ†ºÂºè„ÄÇ' 
      });
    }
    
    // Parse the Word template
    const structure = await wordParser.parseTemplate(file.path);
    
    // Debug: Check if originalHtml is preserved
    console.log(`üìä Structure analysis after parsing:`);
    console.log(`  - Title: "${structure.title}"`);
    console.log(`  - Sections count: ${structure.sections ? structure.sections.length : 0}`);
    console.log(`  - Original HTML length: ${structure.originalHtml ? structure.originalHtml.length : 0}`);
    
    if (!structure.originalHtml || structure.originalHtml.length === 0) {
      console.error('‚ö†Ô∏è WARNING: originalHtml is missing or empty after parsing!');
    } else {
      console.log(`‚úÖ Original HTML preserved: ${structure.originalHtml.length} characters`);
    }
    
    // Â§ÑÁêÜÊñá‰ª∂ÂêçÁºñÁ†ÅÈóÆÈ¢ò
    let cleanFileName = file.originalname;
    try {
      // Â∞ùËØïÂ§ÑÁêÜÂèØËÉΩÁöÑÁºñÁ†ÅÈóÆÈ¢ò
      if (Buffer.isBuffer(file.originalname)) {
        cleanFileName = file.originalname.toString('utf8');
      } else if (typeof file.originalname === 'string') {
        // Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´‰π±Á†ÅÔºåÂ¶ÇÊûúÊúâÂàô‰ΩøÁî®Áî®Êà∑ËæìÂÖ•ÁöÑÂêçÁß∞
        const hasGarbledText = /[ÔøΩÔøΩ]/.test(file.originalname) || 
                              /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/.test(file.originalname) ||
                              /[√•√®√¶√£]/g.test(file.originalname) || // Â∏∏ËßÅÁöÑUTF-8‰π±Á†ÅÂ≠óÁ¨¶
                              file.originalname.includes('√£') ||
                              file.originalname.includes('√¶') ||
                              /[^\x00-\x7F\u4e00-\u9fff\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\u30a0-\u30ff]/.test(file.originalname);
        if (hasGarbledText && name) {
          cleanFileName = name + '.docx';
        }
      }
    } catch (error) {
      console.warn('Error processing filename encoding:', error);
      cleanFileName = name ? name + '.docx' : 'template.docx';
    }
    
    // Create a minimal structure for database storage - only essential metadata
    const tableSections = structure.sections ? structure.sections.filter(s => s.hasTable) : [];
    const minimalStructure = {
      title: structure.title || "",
      totalTables: tableSections.length
    };

    console.log(`Original structure size: ${JSON.stringify(structure).length} characters`);
    console.log(`Minimal structure size: ${JSON.stringify(minimalStructure).length} characters`);
    console.log('Minimal structure summary:', {
      title: minimalStructure.title,
      totalTables: minimalStructure.totalTables
    });
    
    // Store full structure in a separate cache file for configuration access
    const cacheDir = path.join(__dirname, 'cache');
    if (!fs.existsSync(cacheDir)) {
      fs.mkdirSync(cacheDir);
    }
    
    const templateId = `template_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const cacheFilePath = path.join(cacheDir, `${templateId}.json`);
    fs.writeFileSync(cacheFilePath, JSON.stringify(structure));
    console.log(`Full structure cached to: ${cacheFilePath}`);

    // Save minimal template to database
    console.log('üîÑ Attempting to save template to database...');
    console.log('Template data:', {
      id: templateId,
      name: name || cleanFileName.replace(/\.(doc|docx)$/i, ''),
      originalFileName: cleanFileName,
      filePath: file.path,
      structureSize: JSON.stringify(minimalStructure).length
    });
    
    // Ê≠£Á°ÆÁöÑÊï∞ÊçÆÂ∫ìÊèíÂÖ•ÈÄªËæëÔºö
    // 1. ÂÖàÊèíÂÖ•Ê®°ÊùøÂü∫Êú¨‰ø°ÊÅØÂà∞ rs_report_templates
    // 2. ÂÜçÊèíÂÖ•ÊØè‰∏™Ë°®Ê†ºÈÖçÁΩÆÂà∞ rs_template_configs
    
    console.log('üîÑ Inserting template and configurations to database...');
    
    try {
      // ËÆæÁΩÆËæÉÈïøÁöÑË∂ÖÊó∂Êó∂Èó¥‰ª•Â§ÑÁêÜÂ§ßÊñá‰ª∂
      const startTime = Date.now();
      console.log(`Starting database operations at ${new Date().toISOString()}`);
      
      // ÊèíÂÖ•Ê®°ÊùøÂü∫Êú¨‰ø°ÊÅØ
      const template = await prisma.rs_report_templates.create({
        data: {
          id: templateId,
          name: name || cleanFileName.replace(/\.(doc|docx)$/i, ''),
          originalFileName: cleanFileName,
          filePath: file.path,
          structure: minimalStructure, // Âè™Â≠òÂÇ®Âü∫Êú¨‰ø°ÊÅØ
          updatedAt: new Date()
        }
      });
      
      console.log('‚úÖ Template basic info saved:', template.id);
      
      // ÂàÜÊâπÊèíÂÖ•Ë°®Ê†ºÈÖçÁΩÆÂà∞ rs_template_configs - ‰ºòÂåñÂ§ßÊñá‰ª∂Â§ÑÁêÜ
      const tableSections = structure.sections ? structure.sections.filter(s => s.hasTable) : [];
      console.log(`Processing ${tableSections.length} table sections...`);
      
      const BATCH_SIZE = 10; // ÊØèÊâπÂ§ÑÁêÜ10‰∏™Ë°®Ê†º
      let totalInserted = 0;
      
      for (let batch = 0; batch < Math.ceil(tableSections.length / BATCH_SIZE); batch++) {
        const startIndex = batch * BATCH_SIZE;
        const endIndex = Math.min(startIndex + BATCH_SIZE, tableSections.length);
        const batchSections = tableSections.slice(startIndex, endIndex);
        
        const configs = batchSections.map((section, index) => {
          const globalIndex = startIndex + index;
          const configId = `config_${templateId}_${globalIndex}`;
          
          // Âè™Â≠òÂÇ®Âü∫Êú¨‰ø°ÊÅØÔºåÈÅøÂÖçÂ§ßÂØπË±°
          const essentialInfo = {
            tableIndex: globalIndex,
            columnCount: section.tableStructure?.columnCount || 0,
            rowCount: section.tableStructure?.rowCount || 0,
            hasHeaders: !!(section.tableStructure?.headers?.length)
          };
          
          return {
            id: configId,
            templateId: templateId,
            sectionId: section.id || `table_${globalIndex}`,
            sectionName: section.title || `Ë°®Ê†º${globalIndex + 1}`,
            dataType: 'MANUAL', // ÈªòËÆ§ÊâãÂä®Â°´ÂÜô
            value: JSON.stringify(essentialInfo), // Âè™Â≠òÂÇ®Âü∫Êú¨‰ø°ÊÅØ
            sqlQuery: null,
            dataSourceId: null,
            columnIndex: globalIndex,
            parentSectionId: null,
            updatedAt: new Date()
          };
        });
        
        if (configs.length > 0) {
          await prisma.rs_template_configs.createMany({
            data: configs
          });
          totalInserted += configs.length;
          console.log(`‚úÖ Batch ${batch + 1}: Inserted ${configs.length} configurations (Total: ${totalInserted}/${tableSections.length})`);
        }
      }
      
      console.log(`‚úÖ All table configurations saved: ${totalInserted} total`);
      
      const endTime = Date.now();
      const processingTime = (endTime - startTime) / 1000;
      console.log(`‚è±Ô∏è Total processing time: ${processingTime.toFixed(2)} seconds`);
      
      res.json({
        success: true,
        template,
        configsCount: totalInserted,
        processingTime: processingTime
      });
      
    } catch (dbError) {
      console.error('‚ùå Database insertion failed:', dbError);
      throw dbError;
    }
    
    return;
    
    // TODO: ‰øÆÂ§çÊï∞ÊçÆÂ∫ìÊèíÂÖ•ÈóÆÈ¢òÂêéÊÅ¢Â§çËøôÈÉ®ÂàÜ‰ª£Á†Å
    try {
      const template = await prisma.rs_report_templates.create({
        data: {
          id: templateId,
          name: name || cleanFileName.replace(/\.(doc|docx)$/i, ''),
          originalFileName: cleanFileName,
          filePath: file.path,
          structure: minimalStructure,
          updatedAt: new Date()
        }
      });
      
      console.log('‚úÖ Template saved to database successfully:', template.id);
      
      // ÊàêÂäü‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
      res.json({
        success: true,
        template
      });
      return; // Á°Æ‰øùÊàêÂäüÂêéÁõ¥Êé•ËøîÂõû
    } catch (dbError) {
      console.error('‚ùå Database save failed:', dbError);
      console.error('Error name:', dbError.name);
      console.error('Error message:', dbError.message);
      
      // Â∞ùËØï‰øùÂ≠ò‰∏Ä‰∏™Êõ¥ÁÆÄÂåñÁöÑÁâàÊú¨
      console.log('üîÑ Attempting to save ultra-minimal version...');
      const ultraMinimal = {
        title: structure.title || "",
        totalTables: tableSections.length
      };
      
      try {
        const template = await prisma.rs_report_templates.create({
          data: {
            id: templateId,
            name: name || cleanFileName.replace(/\.(doc|docx)$/i, ''),
            originalFileName: cleanFileName,
            filePath: file.path,
            structure: ultraMinimal,
            updatedAt: new Date()
          }
        });
        console.log('‚úÖ Ultra-minimal template saved successfully:', template.id);
      } catch (secondError) {
        console.error('‚ùå Even ultra-minimal save failed:', secondError);
        throw dbError; // ÊäõÂá∫ÂéüÂßãÈîôËØØ
      }
    }
    
    res.json({
      success: true,
      template
    });
  } catch (error) {
    console.error('Upload error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get all templates
app.get('/api/templates', async (req, res) => {
  try {
    const templates = await prisma.rs_report_templates.findMany({
      orderBy: { createdAt: 'desc' }
    });
    
    // Âú®ËøîÂõûÂâçÂ§ÑÁêÜÂèØËÉΩÁöÑÁºñÁ†ÅÈóÆÈ¢ò
    const cleanTemplates = templates.map(template => {
      let cleanOriginalFileName = template.originalFileName;
      
      if (cleanOriginalFileName) {
        try {
          // Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´‰π±Á†ÅÂ≠óÁ¨¶
          const hasGarbledText = /[ÔøΩÔøΩ]/.test(cleanOriginalFileName) || 
                                /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/.test(cleanOriginalFileName) ||
                                /[√•√®√¶√£]/g.test(cleanOriginalFileName) || // Â∏∏ËßÅÁöÑUTF-8‰π±Á†ÅÂ≠óÁ¨¶
                                cleanOriginalFileName.includes('√£') ||
                                cleanOriginalFileName.includes('√¶') ||
                                /[^\x00-\x7F\u4e00-\u9fff\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\u30a0-\u30ff]/.test(cleanOriginalFileName);
          
          if (hasGarbledText) {
            // Â¶ÇÊûúÊúâ‰π±Á†ÅÔºå‰ΩøÁî®Ê®°ÊùøÂêçÁß∞ + .docx
            cleanOriginalFileName = template.name + '.docx';
          }
        } catch (error) {
          console.warn('Error processing template filename:', error);
          cleanOriginalFileName = template.name + '.docx';
        }
      }
      
      return {
        ...template,
        originalFileName: cleanOriginalFileName
      };
    });
    
    res.json(cleanTemplates);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get template with configs
app.get('/api/templates/:id', async (req, res) => {
  try {
    const template = await prisma.rs_report_templates.findUnique({
      where: { id: req.params.id },
      include: {
        rs_template_configs: {
          include: {
            rs_data_sources: true
          }
        }
      }
    });
    
    if (!template) {
      return res.status(404).json({ error: 'Template not found' });
    }
    
    // Â∞ùËØïÂä†ËΩΩÁºìÂ≠òÁöÑHTMLÂÜÖÂÆπ
    let htmlContent = null;
    if (template.id) {
      const cacheFile = path.join(__dirname, 'cache', `${template.id}.json`);
      try {
        if (fs.existsSync(cacheFile)) {
          const cacheData = JSON.parse(fs.readFileSync(cacheFile, 'utf8'));
          if (cacheData.htmlContent) {
            htmlContent = cacheData.htmlContent;
            console.log(`Loaded HTML content for template ${template.id}, length: ${htmlContent.length}`);
          } else if (cacheData.sections && Array.isArray(cacheData.sections)) {
            // ÈáçÂª∫HTMLÂÜÖÂÆπ‰ªésectionsÊï∞ÊçÆÔºå‰ºòÂÖà‰ΩøÁî®ÂéüÂßãHTML
            htmlContent = reconstructHtmlFromSections(cacheData.sections, cacheData.title, cacheData.originalHtml);
            console.log(`Reconstructed HTML content for template ${template.id}, length: ${htmlContent.length}`);
          }
        }
      } catch (error) {
        console.error('Error loading cached HTML:', error);
      }
    }
    
    res.json({
      ...template,
      htmlContent
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get full template structure from cache for configuration
app.get('/api/templates/:id/full-structure', async (req, res) => {
  try {
    const cacheFilePath = path.join(__dirname, 'cache', `${req.params.id}.json`);
    
    if (!fs.existsSync(cacheFilePath)) {
      return res.status(404).json({ error: 'Full structure cache not found' });
    }
    
    const fullStructure = JSON.parse(fs.readFileSync(cacheFilePath, 'utf8'));
    res.json(fullStructure);
  } catch (error) {
    console.error('Error loading full structure:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get template HTML preview
app.get('/api/templates/:id/preview', async (req, res) => {
  try {
    const { id } = req.params;
    
    // È¶ñÂÖà‰ªéÊï∞ÊçÆÂ∫ìËé∑ÂèñÊ®°Êùø‰ø°ÊÅØ
    const template = await prisma.rs_report_templates.findUnique({
      where: { id }
    });
    
    if (!template) {
      return res.status(404).json({ error: 'Template not found' });
    }
    
    // Â∞ùËØï‰ªéÁºìÂ≠òËé∑ÂèñÂÆåÊï¥ÁªìÊûÑÔºàÂåÖÂê´HTMLÔºâ
    const cacheFilePath = path.join(__dirname, 'cache', `${id}.json`);
    
    if (fs.existsSync(cacheFilePath)) {
      const fullStructure = JSON.parse(fs.readFileSync(cacheFilePath, 'utf8'));
      if (fullStructure.originalHtml) {
        return res.json({
          success: true,
          html: fullStructure.originalHtml,
          title: fullStructure.title || 'Êú™Áü•ÊñáÊ°£'
        });
      }
    }
    
    // Â¶ÇÊûúÁºìÂ≠ò‰∏çÂ≠òÂú®ÊàñÊ≤°ÊúâHTMLÔºåÈáçÊñ∞Ëß£ÊûêÊñá‰ª∂
    if (fs.existsSync(template.filePath)) {
      console.log('Re-parsing template for HTML preview:', template.filePath);
      const structure = await wordParser.parseTemplate(template.filePath);
      
      res.json({
        success: true,
        html: structure.originalHtml || '<p>Êó†Ê≥ïÁîüÊàêHTMLÈ¢ÑËßà</p>',
        title: structure.title || template.name
      });
    } else {
      res.status(404).json({ error: 'Template file not found' });
    }
  } catch (error) {
    console.error('Error getting template preview:', error);
    res.status(500).json({ error: error.message });
  }
});

// Delete template
app.delete('/api/templates/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Check if template exists
    const template = await prisma.rs_report_templates.findUnique({
      where: { id }
    });
    
    if (!template) {
      return res.status(404).json({ error: 'Template not found' });
    }
    
    // Delete the template (cascade will handle related records)
    await prisma.rs_report_templates.delete({
      where: { id }
    });
    
    // Delete the physical file
    try {
      await fsPromises.unlink(template.filePath);
    } catch (fileError) {
      console.warn('Could not delete template file:', fileError.message);
    }
    
    res.json({ success: true, message: 'Template deleted successfully' });
  } catch (error) {
    console.error('Delete template error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Duplicate template
app.post('/api/templates/:id/duplicate', async (req, res) => {
  try {
    const { id } = req.params;
    const { name } = req.body;
    
    // Get original template with configs
    const originalTemplate = await prisma.rs_report_templates.findUnique({
      where: { id },
      include: {
        rs_template_configs: true
      }
    });
    
    if (!originalTemplate) {
      return res.status(404).json({ error: 'Template not found' });
    }
    
    // Copy the physical file
    const originalPath = originalTemplate.filePath;
    const newFileName = `${uuidv4()}_${originalTemplate.originalFileName}`;
    const newFilePath = path.join(process.env.UPLOAD_DIR, newFileName);
    
    try {
      await fsPromises.copyFile(originalPath, newFilePath);
    } catch (fileError) {
      return res.status(500).json({ error: 'Failed to copy template file' });
    }
    
    // Create new template
    const newTemplateId = uuidv4();
    const newTemplate = await prisma.rs_report_templates.create({
      data: {
        id: newTemplateId,
        name,
        originalFileName: originalTemplate.originalFileName,
        filePath: newFilePath,
        structure: originalTemplate.structure,
        updatedAt: new Date()
      }
    });
    
    // Copy all configs
    if (originalTemplate.rs_template_configs && originalTemplate.rs_template_configs.length > 0) {
      await prisma.rs_template_configs.createMany({
        data: originalTemplate.rs_template_configs.map(config => ({
          templateId: newTemplate.id,
          sectionId: config.sectionId,
          sectionName: config.sectionName,
          dataType: config.dataType,
          value: config.value,
          sqlQuery: config.sqlQuery,
          dataSourceId: config.dataSourceId,
          columnIndex: config.columnIndex,
          parentSectionId: config.parentSectionId
        }))
      });
    }
    
    res.json({
      success: true,
      template: newTemplate,
      message: 'Template duplicated successfully'
    });
  } catch (error) {
    console.error('Duplicate template error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Update template
app.put('/api/templates/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { name, description, workflow, selectedProcess, emailAddress, structure } = req.body;
    
    console.log(`üîß Êõ¥Êñ∞Ê®°Êùø - Ê®°ÊùøID: ${id}`);
    console.log(`üìù Êõ¥Êñ∞Êï∞ÊçÆ:`, { name, description, workflow, selectedProcess, emailAddress, structure: structure ? 'Yes' : 'No' });
    
    // Prepare update data
    const updateData = {
      updatedAt: new Date()
    };
    
    // Only update fields that are provided
    if (name !== undefined) updateData.name = name;
    if (description !== undefined) updateData.description = description;
    if (workflow !== undefined) updateData.workflow = workflow;
    if (selectedProcess !== undefined) updateData.selectedProcess = selectedProcess;
    if (emailAddress !== undefined) updateData.emailAddress = emailAddress;
    if (structure !== undefined) updateData.structure = structure;
    
    // Update template
    const updatedTemplate = await prisma.rs_report_templates.update({
      where: { id },
      data: updateData
    });
    
    console.log(`‚úÖ Ê®°ÊùøÊõ¥Êñ∞ÊàêÂäü: ${updatedTemplate.name}`);
    if (structure) {
      console.log(`üìä Ê®°ÊùøÁªìÊûÑÂ∑≤Êõ¥Êñ∞: ${JSON.stringify(structure).substring(0, 100)}...`);
    }
    
    res.json({
      success: true,
      template: updatedTemplate,
      message: 'Template updated successfully'
    });
  } catch (error) {
    console.error('Update template error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Save template configuration
app.post('/api/templates/:id/config', async (req, res) => {
  try {
    const { id } = req.params;
    const { configs, templateStructure } = req.body;
    
    console.log(`üîß ‰øùÂ≠òÊ®°ÊùøÈÖçÁΩÆ - Ê®°ÊùøID: ${id}`);
    console.log(`üìù Êî∂Âà∞ÈÖçÁΩÆÊï∞Èáè: ${configs ? configs.length : 0}`);
    console.log(`üèóÔ∏è Êî∂Âà∞Ê®°ÊùøÁªìÊûÑÊõ¥Êñ∞: ${templateStructure ? 'Yes' : 'No'}`);
    
    if (configs && configs.length > 0) {
      console.log('Ââç5‰∏™ÈÖçÁΩÆÁ§∫‰æã:');
      configs.slice(0, 5).forEach((config, index) => {
        console.log(`  ${index + 1}. ${config.sectionName}: ${config.dataType} = ${config.value || config.sqlQuery || 'Á©∫'}`);
      });
    }
    
    // Delete existing configs
    const deleteResult = await prisma.rs_template_configs.deleteMany({
      where: { templateId: id }
    });
    console.log(`üóëÔ∏è Âà†Èô§‰∫Ü ${deleteResult.count} ‰∏™ÊóßÈÖçÁΩÆ`);
    
    // Get all valid data source IDs
    const validDataSources = await prisma.rs_data_sources.findMany({
      select: { id: true }
    });
    const validDataSourceIds = new Set(validDataSources.map(ds => ds.id));

    // Create new configs with validated dataSourceId
    const newConfigs = await Promise.all(
      configs.map(config => {
        // Validate dataSourceId exists in database, otherwise set to null
        const validatedDataSourceId = config.dataSourceId && validDataSourceIds.has(config.dataSourceId) 
          ? config.dataSourceId 
          : null;

        return prisma.rs_template_configs.create({
          data: {
            id: uuidv4(),
            templateId: id,
            sectionId: config.sectionId,
            sectionName: config.sectionName,
            dataType: config.dataType,
            value: config.value || '',
            sqlQuery: config.sqlQuery || '',
            dataSourceId: validatedDataSourceId,
            columnIndex: config.columnIndex || null,
            parentSectionId: config.parentSectionId || null,
            createdAt: new Date(),
            updatedAt: new Date()
          }
        })
      })
    );
    
    console.log(`‚úÖ ÊàêÂäü‰øùÂ≠ò ${newConfigs.length} ‰∏™Êñ∞ÈÖçÁΩÆ`);
    
    // Save template structure if provided
    if (templateStructure) {
      console.log(`üèóÔ∏è Êõ¥Êñ∞Ê®°ÊùøÁªìÊûÑ...`);
      
      // Update the database structure
      await prisma.rs_report_templates.update({
        where: { id: id },
        data: {
          structure: templateStructure,
          updatedAt: new Date()
        }
      });
      
      // Update the cache file
      const cacheDir = path.join(__dirname, 'cache');
      const cacheFilePath = path.join(cacheDir, `${id}.json`);
      
      // Ensure cache directory exists
      if (!fs.existsSync(cacheDir)) {
        fs.mkdirSync(cacheDir, { recursive: true });
      }
      
      // Write updated structure to cache
      fs.writeFileSync(cacheFilePath, JSON.stringify(templateStructure, null, 2));
      console.log(`üíæ Â∑≤Êõ¥Êñ∞ÁºìÂ≠òÊñá‰ª∂: ${cacheFilePath}`);
      console.log(`üìä ÁªìÊûÑ‰ø°ÊÅØ: sections=${templateStructure.sections ? templateStructure.sections.length : 0}`);
    }
    
    res.json({
      success: true,
      configs: newConfigs
    });
  } catch (error) {
    console.error('‚ùå ‰øùÂ≠òÈÖçÁΩÆÂ§±Ë¥•:', error.message);
    res.status(500).json({ error: error.message });
  }
});

// Save template HTML content for TinyMCE editor
app.post('/api/templates/:id/save-html', async (req, res) => {
  try {
    const { id } = req.params;
    const { html } = req.body;
    
    if (!html) {
      return res.status(400).json({ error: 'HTML content is required' });
    }
    
    console.log(`üíæ Saving HTML content for template ${id}, length: ${html.length}`);
    
    // Update cache file with new HTML content
    const cacheDir = path.join(__dirname, 'cache');
    const cacheFilePath = path.join(cacheDir, `${id}.json`);
    
    // Ensure cache directory exists
    if (!fs.existsSync(cacheDir)) {
      fs.mkdirSync(cacheDir, { recursive: true });
    }
    
    // Load existing cache or create new one
    let cacheData = {};
    if (fs.existsSync(cacheFilePath)) {
      try {
        cacheData = JSON.parse(fs.readFileSync(cacheFilePath, 'utf8'));
      } catch (error) {
        console.error('Error reading cache file:', error);
      }
    }
    
    // Update HTML content
    cacheData.htmlContent = html;
    cacheData.lastUpdated = new Date().toISOString();
    
    // Save updated cache
    fs.writeFileSync(cacheFilePath, JSON.stringify(cacheData, null, 2));
    
    console.log(`‚úÖ HTML content saved to cache for template ${id}`);
    
    res.json({ 
      success: true,
      message: 'HTML content saved successfully'
    });
  } catch (error) {
    console.error('Error saving HTML content:', error);
    res.status(500).json({ error: error.message });
  }
});

// Data sources management
app.get('/api/datasources', async (req, res) => {
  try {
    const dataSources = await prisma.rs_data_sources.findMany({
      where: { active: true }
    });
    res.json(dataSources);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/datasources', async (req, res) => {
  try {
    const dataSource = await prisma.rs_data_sources.create({
      data: req.body
    });
    res.json(dataSource);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/datasources/test', async (req, res) => {
  try {
    const { host, port, database, username, password, sqlQuery, dataSourceId } = req.body;
    
    // If we have a dataSourceId, try to return mock data first
    if (dataSourceId) {
      try {
        const dataSource = await prisma.rs_data_sources.findUnique({
          where: { id: dataSourceId }
        });
        
        if (dataSource) {
          const { mockSampleData } = require('./scripts/seed-mock-data');
          const sampleData = mockSampleData[dataSource.name];
          
          if (sampleData) {
            console.log(`üé≠ ËøîÂõûMockÊï∞ÊçÆ for ${dataSource.name}:`, sampleData.length, 'Êù°ËÆ∞ÂΩï');
            return res.json({
              success: true,
              message: `MockÊï∞ÊçÆÊü•ËØ¢ÊàêÂäü - ${dataSource.name}`,
              rowCount: sampleData.length,
              sample: sampleData.slice(0, 5),
              isMockData: true
            });
          }
        }
      } catch (mockError) {
        console.warn('MockÊï∞ÊçÆËé∑ÂèñÂ§±Ë¥•ÔºåÂ∞ùËØïÁúüÂÆûËøûÊé•:', mockError.message);
      }
    }
    
    // Fallback to real database connection
    const { Client } = require('pg');
    
    const client = new Client({
      host,
      port,
      database,
      user: username,
      password
    });
    
    await client.connect();
    
    if (sqlQuery) {
      const result = await client.query(sqlQuery);
      await client.end();
      res.json({ 
        success: true, 
        message: 'Connection and query successful',
        rowCount: result.rowCount,
        sample: result.rows.slice(0, 5),
        isMockData: false
      });
    } else {
      await client.end();
      res.json({ success: true, message: 'Connection successful', isMockData: false });
    }
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Scheduled tasks
app.get('/api/tasks', async (req, res) => {
  try {
    const tasks = await prisma.rs_scheduled_tasks.findMany({
      include: {
        rs_report_templates: true
      }
    });
    res.json(tasks);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/tasks', async (req, res) => {
  try {
    const task = await prisma.rs_scheduled_tasks.create({
      data: req.body
    });
    
    // Schedule the task
    if (task.active) {
      taskScheduler.scheduleTask(task);
    }
    
    res.json(task);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.put('/api/tasks/:id/toggle', async (req, res) => {
  try {
    const task = await prisma.rs_scheduled_tasks.findUnique({
      where: { id: req.params.id }
    });
    
    const updatedTask = await prisma.rs_scheduled_tasks.update({
      where: { id: req.params.id },
      data: { active: !task.active }
    });
    
    if (updatedTask.active) {
      taskScheduler.scheduleTask(updatedTask);
    } else {
      taskScheduler.cancelTask(updatedTask.id);
    }
    
    res.json(updatedTask);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Generate report manually
app.post('/api/reports/generate/:templateId', async (req, res) => {
  try {
    const { templateId } = req.params;
    const report = await reportGenerator.generateReport(templateId);
    res.json(report);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get generated reports
app.get('/api/reports', async (req, res) => {
  try {
    const reports = await prisma.rs_generated_reports.findMany({
      include: {
        rs_report_templates: true,
        rs_scheduled_tasks: true
      },
      orderBy: { generatedAt: 'desc' }
    });
    res.json(reports);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Download report
app.get('/api/reports/download/:id', async (req, res) => {
  try {
    const report = await prisma.rs_generated_reports.findUnique({
      where: { id: req.params.id }
    });
    
    if (!report) {
      return res.status(404).json({ error: 'Report not found' });
    }
    
    res.download(report.filePath, report.reportName);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Fix template descriptions (‰øÆÂ§çÊ®°ÊùøÊèèËø∞‰π±Á†Å)
app.post('/api/templates/fix-descriptions', async (req, res) => {
  try {
    const templates = await prisma.rs_report_templates.findMany();
    let fixedCount = 0;
    
    for (const template of templates) {
      if (template.originalFileName) {
        const hasGarbledText = /[ÔøΩÔøΩ]/.test(template.originalFileName) || 
                              /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/.test(template.originalFileName) ||
                              /[√•√®√¶√£]/g.test(template.originalFileName) || // Â∏∏ËßÅÁöÑUTF-8‰π±Á†ÅÂ≠óÁ¨¶
                              template.originalFileName.includes('√£') ||
                              template.originalFileName.includes('√¶') ||
                              /[^\x00-\x7F\u4e00-\u9fff\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\u30a0-\u30ff]/.test(template.originalFileName);
        
        if (hasGarbledText && template.name) {
          const cleanFileName = template.name + '.docx';
          await prisma.rs_report_templates.update({
            where: { id: template.id },
            data: { originalFileName: cleanFileName }
          });
          fixedCount++;
          console.log(`Fixed template ${template.id}: ${template.originalFileName} -> ${cleanFileName}`);
        }
      }
    }
    
    res.json({
      success: true,
      message: `Fixed ${fixedCount} templates with garbled descriptions`,
      fixedCount
    });
  } catch (error) {
    console.error('Fix descriptions error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Re-parse template structure (ÈáçÊñ∞Ëß£ÊûêÊ®°ÊùøÁªìÊûÑ)
app.post('/api/templates/:id/reparse', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Ëé∑ÂèñÊ®°Êùø‰ø°ÊÅØ
    const template = await prisma.rs_report_templates.findUnique({
      where: { id }
    });
    
    if (!template) {
      return res.status(404).json({ error: 'Template not found' });
    }
    
    // ÈáçÊñ∞Ëß£ÊûêWordÊñáÊ°£
    const structure = await wordParser.parseTemplate(template.filePath);
    
    // Êõ¥Êñ∞Êï∞ÊçÆÂ∫ì‰∏≠ÁöÑÁªìÊûÑ‰ø°ÊÅØ
    const updatedTemplate = await prisma.rs_report_templates.update({
      where: { id },
      data: { structure }
    });
    
    console.log('Re-parsed template structure:', JSON.stringify(structure, null, 2));
    
    res.json({
      success: true,
      template: updatedTemplate,
      message: 'Template structure re-parsed successfully'
    });
  } catch (error) {
    console.error('Re-parse template error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get all data sources
app.get('/api/data-sources', async (req, res) => {
  try {
    const dataSources = await prisma.rs_data_sources.findMany({
      where: { active: true },
      orderBy: { name: 'asc' }
    });
    res.json(dataSources);
  } catch (error) {
    console.error('Error fetching data sources:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get mock sample data for a data source (for testing)
app.get('/api/datasources/:id/sample', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get data source info
    const dataSource = await prisma.rs_data_sources.findUnique({
      where: { id }
    });
    
    if (!dataSource) {
      return res.status(404).json({ error: 'Data source not found' });
    }
    
    // Return mock sample data
    const { mockSampleData } = require('./scripts/seed-mock-data');
    const sampleData = mockSampleData[dataSource.name];
    
    if (!sampleData) {
      return res.status(404).json({ error: 'No sample data available for this data source' });
    }
    
    res.json({
      success: true,
      dataSource: {
        id: dataSource.id,
        name: dataSource.name,
        type: dataSource.type
      },
      sampleData,
      count: sampleData.length,
      isMockData: true
    });
  } catch (error) {
    console.error('Error fetching sample data:', error);
    res.status(500).json({ error: error.message });
  }
});

// Import Word document to HTML for TinyMCE editor
app.post('/api/templates/import-word', upload.single('file'), async (req, res) => {
  try {
    const file = req.file;
    
    if (!file) {
      return res.status(400).json({ error: 'ËØ∑‰∏ä‰º†WordÊñáÊ°£' });
    }
    
    // È™åËØÅÊñáÊ°£Ê†ºÂºè
    await htmlWordConverter.validateWordDocument(file.path);
    
    // ËΩ¨Êç¢‰∏∫HTML
    const result = await htmlWordConverter.wordToHtml(file.path);
    
    // Â§ÑÁêÜË°®Ê†º‰ΩøÂÖ∂ÂèØÁºñËæë
    let processedHtml = htmlWordConverter.makeTablesEditable(result.html);
    
    // Â§ÑÁêÜÂêàÂπ∂ÂçïÂÖÉÊ†º
    processedHtml = htmlWordConverter.processMergedCells(processedHtml);
    
    // Ê∏ÖÁêÜWordÁâπÊúâÁöÑÊ†áËÆ∞
    processedHtml = htmlWordConverter.cleanWordHtml(processedHtml);
    
    // ÊèêÂèñË°®Ê†ºÁªìÊûÑ
    const tableStructures = htmlWordConverter.extractTableStructure(processedHtml);
    
    // Âà†Èô§‰∏¥Êó∂Êñá‰ª∂
    await fsPromises.unlink(file.path).catch(console.error);
    
    res.json({
      success: true,
      htmlContent: processedHtml,
      tables: tableStructures,
      messages: result.messages
    });
  } catch (error) {
    console.error('Word import error:', error);
    // Âà†Èô§‰∏¥Êó∂Êñá‰ª∂
    if (req.file) {
      await fsPromises.unlink(req.file.path).catch(console.error);
    }
    res.status(500).json({ 
      error: error.message || 'ÊñáÊ°£ÂØºÂÖ•Â§±Ë¥•'
    });
  }
});

// Export HTML to Word document with dataset support
app.post('/api/templates/:id/export-word', async (req, res) => {
  try {
    const { id } = req.params;
    const { htmlContent } = req.body;

    if (!htmlContent) {
      return res.status(400).json({ error: 'Áº∫Â∞ëHTMLÂÜÖÂÆπ' });
    }

    // Ëé∑ÂèñÊ®°Êùø‰ø°ÊÅØ
    const template = await prisma.rs_report_templates.findUnique({
      where: { id }
    });

    if (!template) {
      return res.status(404).json({ error: 'Ê®°Êùø‰∏çÂ≠òÂú®' });
    }

    // Â§ÑÁêÜHTML‰∏≠ÁöÑÊï∞ÊçÆÈõÜÂç†‰ΩçÁ¨¶
    console.log('üìä Processing datasets for template:', id);
    let processedHtml = htmlContent;

    // Êü•ÊâæÊâÄÊúâÊï∞ÊçÆÈõÜÂç†‰ΩçÁ¨¶ {{dataset:id:name}}
    const datasetPattern = /\{\{dataset:(\d+):([^}]+)\}\}/g;
    const matches = [...processedHtml.matchAll(datasetPattern)];

    for (const match of matches) {
      const [placeholder, datasetId, datasetName] = match;
      console.log(`Processing dataset: ${datasetName} (ID: ${datasetId})`);

      try {
        // Ëé∑ÂèñÊï∞ÊçÆÈõÜÂπ∂ÊâßË°åÊü•ËØ¢
        const dataset = datasetStore.getDataset(datasetId);
        if (dataset) {
          const rows = await prisma.$queryRawUnsafe(dataset.sqlQuery);
          const dataResult = {
            type: dataset.type,
            fields: dataset.fields,
            data: dataset.type === 'single' ? rows[0] || {} : rows
          };

          const dataHtml = formatDatasetAsHtml(dataResult);
          processedHtml = processedHtml.replace(placeholder, dataHtml);
        } else {
          console.warn(`Dataset not found: ${datasetId}`);
          processedHtml = processedHtml.replace(placeholder, `[Êï∞ÊçÆÈõÜÊú™ÊâæÂà∞: ${datasetName}]`);
        }
      } catch (error) {
        console.error(`Error processing dataset ${datasetId}:`, error);
        processedHtml = processedHtml.replace(placeholder, `[Êï∞ÊçÆÈõÜÈîôËØØ: ${error.message}]`);
      }
    }

    // ÁîüÊàêËæìÂá∫Êñá‰ª∂Ë∑ØÂæÑ
    const outputFileName = `${template.name}_${Date.now()}.docx`;
    const outputPath = path.join(process.env.REPORTS_DIR, outputFileName);

    // ËΩ¨Êç¢HTML‰∏∫WordÔºå‰º†ÈÄíprismaÂÆû‰æãÁî®‰∫éÊï∞ÊçÆÊü•ËØ¢
    await htmlWordConverter.htmlToWord(processedHtml, outputPath, prisma);

    // ÂèëÈÄÅÊñá‰ª∂
    res.download(outputPath, outputFileName, (err) => {
      if (err) {
        console.error('File download error:', err);
      }
      // Âà†Èô§‰∏¥Êó∂Êñá‰ª∂
      fsPromises.unlink(outputPath).catch(console.error);
    });
  } catch (error) {
    console.error('Word export error:', error);
    res.status(500).json({
      error: error.message || 'ÊñáÊ°£ÂØºÂá∫Â§±Ë¥•'
    });
  }
});

// Helper function to format dataset as HTML
function formatDatasetAsHtml(datasetResult) {
  if (!datasetResult) return '';

  switch (datasetResult.type) {
    case 'text':
      return datasetResult.value;

    case 'single':
      const values = datasetResult.fields.map(field =>
        `<strong>${field}:</strong> ${datasetResult.data[field] || ''}`
      );
      return values.join('<br>');

    case 'list':
      let html = '<table border="1" style="border-collapse: collapse; width: 100%;">';
      // Add header
      html += '<tr>';
      datasetResult.fields.forEach(field => {
        html += `<th style="padding: 8px; background-color: #f2f2f2;">${field}</th>`;
      });
      html += '</tr>';
      // Add data rows
      datasetResult.data.forEach(row => {
        html += '<tr>';
        datasetResult.fields.forEach(field => {
          html += `<td style="padding: 8px;">${row[field] || ''}</td>`;
        });
        html += '</tr>';
      });
      html += '</table>';
      return html;

    case 'error':
      return `<span style="color: red;">Error: ${datasetResult.message}</span>`;

    default:
      return '';
  }
}

// Save template with HTML content
app.post('/api/templates/:id/save-html', async (req, res) => {
  try {
    const { id } = req.params;
    const { html, htmlContent, structure } = req.body;
    const content = html || htmlContent; // ÂÖºÂÆπ‰∏§ÁßçÂ≠óÊÆµÂêç
    
    // Êõ¥Êñ∞Ê®°ÊùøÁöÑHTMLÂÜÖÂÆπ
    const template = await prisma.rs_report_templates.update({
      where: { id },
      data: {
        htmlContent: content,
        structure: structure ? JSON.stringify(structure) : null,
        updatedAt: new Date()
      }
    });
    
    res.json({
      success: true,
      template
    });
  } catch (error) {
    console.error('Save template HTML error:', error);
    res.status(500).json({ 
      error: error.message || '‰øùÂ≠òÂ§±Ë¥•'
    });
  }
});

// Get data source fields (for dataset configuration)
app.get('/api/datasources/:id/fields', async (req, res) => {
  try {
    const dataSourceId = parseInt(req.params.id);
    console.log('Getting fields for data source:', dataSourceId);

    // Ê†πÊçÆÊï∞ÊçÆÊ∫êIDËøîÂõû‰∏çÂêåÁöÑÂ≠óÊÆµÈõÜÂêà
    let mockFields = [];
    
    switch (dataSourceId) {
      case 1: // Ê¥ªË∑ÉÊé•Âè£Ê∏ÖÂçïÊï∞ÊçÆÊ∫ê
        mockFields = [
          { label: 'Ë∑ØÂæÑ', value: 'path', type: 'string' },
          { label: 'Êé•Âè£Ê®°Âºè', value: 'interface_schema', type: 'string' },
          { label: 'ÂüüÂêç', value: 'domain', type: 'string' },
          { label: 'ÈÄöËøáÊù•Ê∫ê', value: 'pass_source', type: 'string' },
          { label: 'ÊñπÊ≥ï', value: 'method', type: 'string' },
          { label: 'ËØ∑Ê±ÇÊó∂Èó¥', value: 'request_time', type: 'date' },
          { label: 'ÂìçÂ∫îÁä∂ÊÄÅ', value: 'response_status', type: 'number' },
          { label: 'Êé•Âè£Á±ªÂûã', value: 'interface_type', type: 'string' },
          { label: 'ÂÆâÂÖ®Á∫ßÂà´', value: 'security_level', type: 'string' }
        ];
        break;
        
      case 2: // ÂÆ°ËÆ°Êï∞ÊçÆÂ∫ì
        mockFields = [
          { label: 'ÂÆ°ËÆ°ÂêçÁß∞', value: 'audit_name', type: 'string' },
          { label: 'ÂÆ°ËÆ°Êó∂Èó¥', value: 'audit_date', type: 'date' },
          { label: 'È£éÈô©Á≠âÁ∫ß', value: 'risk_level', type: 'string' },
          { label: 'Ë¥£‰ªªÈÉ®Èó®', value: 'department', type: 'string' },
          { label: 'Êï¥ÊîπÁä∂ÊÄÅ', value: 'rectification_status', type: 'string' },
          { label: 'ÂèëÁé∞ÈóÆÈ¢òÊï∞', value: 'issue_count', type: 'number' },
          { label: 'Â∑≤Êï¥ÊîπÊï∞', value: 'resolved_count', type: 'number' },
          { label: 'Êï¥ÊîπÁéá', value: 'rectification_rate', type: 'percentage' },
          { label: 'È£éÈô©ËØÑÂàÜ', value: 'risk_score', type: 'number' },
          { label: 'ÂÆ°ËÆ°‰∫∫Âëò', value: 'auditor', type: 'string' }
        ];
        break;
        
      case 3: // ÂÆâÂÖ®‰∫ã‰ª∂Â∫ì
        mockFields = [
          { label: '‰∫ã‰ª∂ID', value: 'incident_id', type: 'string' },
          { label: '‰∫ã‰ª∂Ê†áÈ¢ò', value: 'incident_title', type: 'string' },
          { label: 'ÂèëÁîüÊó∂Èó¥', value: 'occurrence_time', type: 'date' },
          { label: '‰∫ã‰ª∂Á±ªÂûã', value: 'incident_type', type: 'string' },
          { label: '‰∏•ÈáçÁ®ãÂ∫¶', value: 'severity', type: 'string' },
          { label: 'ÂΩ±ÂìçËåÉÂõ¥', value: 'impact_scope', type: 'string' },
          { label: 'Â§ÑÁêÜÁä∂ÊÄÅ', value: 'handling_status', type: 'string' },
          { label: 'Ë¥üË¥£‰∫∫', value: 'responsible_person', type: 'string' },
          { label: 'Ê∫êIP', value: 'source_ip', type: 'string' },
          { label: 'ÁõÆÊ†áIP', value: 'target_ip', type: 'string' }
        ];
        break;
        
      default: // ÈªòËÆ§Â≠óÊÆµÈõÜÂêà
        mockFields = [
          { label: 'Ë∑ØÂæÑ', value: 'path', type: 'string' },
          { label: 'Êé•Âè£Ê®°Âºè', value: 'interface_schema', type: 'string' },
          { label: 'ÂüüÂêç', value: 'domain', type: 'string' },
          { label: 'ÈÄöËøáÊù•Ê∫ê', value: 'pass_source', type: 'string' },
          { label: 'ÊñπÊ≥ï', value: 'method', type: 'string' },
          { label: 'ÂÆ°ËÆ°ÂêçÁß∞', value: 'audit_name', type: 'string' },
          { label: 'ÂÆ°ËÆ°Êó∂Èó¥', value: 'audit_date', type: 'date' },
          { label: 'È£éÈô©Á≠âÁ∫ß', value: 'risk_level', type: 'string' }
        ];
    }

    console.log(`‚úÖ Retrieved ${mockFields.length} fields for data source ${dataSourceId}`);

    res.json({
      success: true,
      fields: mockFields
    });

  } catch (error) {
    console.error('Get data source fields error:', error);
    res.status(500).json({ 
      error: error.message || 'Ëé∑ÂèñÊï∞ÊçÆÊ∫êÂ≠óÊÆµÂ§±Ë¥•'
    });
  }
});

// Dataset Configuration APIs
// ÈÖçÁΩÆÂçïÂÖÉÊ†ºÊï∞ÊçÆÈõÜ
app.post('/api/templates/:templateId/cells/:cellId/dataset', async (req, res) => {
  try {
    const { templateId, cellId } = req.params;
    const config = req.body;

    console.log('üìä Configuring dataset for cell:', cellId, 'in template:', templateId);

    datasetConfig.addConfig(parseInt(templateId), cellId, config);

    res.json({
      success: true,
      message: 'Êï∞ÊçÆÈõÜÈÖçÁΩÆÂ∑≤‰øùÂ≠ò'
    });
  } catch (error) {
    console.error('Dataset config error:', error);
    res.status(500).json({ error: error.message || 'ÈÖçÁΩÆ‰øùÂ≠òÂ§±Ë¥•' });
  }
});

// Ëé∑ÂèñÂçïÂÖÉÊ†ºÊï∞ÊçÆÈõÜÈÖçÁΩÆ
app.get('/api/templates/:templateId/cells/:cellId/dataset', async (req, res) => {
  try {
    const { templateId, cellId } = req.params;
    const config = datasetConfig.getConfig(parseInt(templateId), cellId);

    res.json({
      success: true,
      config: config || null
    });
  } catch (error) {
    console.error('Get dataset config error:', error);
    res.status(500).json({ error: error.message || 'Ëé∑ÂèñÈÖçÁΩÆÂ§±Ë¥•' });
  }
});

// Ëé∑ÂèñÊ®°ÊùøÊâÄÊúâÊï∞ÊçÆÈõÜÈÖçÁΩÆ
app.get('/api/templates/:templateId/datasets', async (req, res) => {
  try {
    const { templateId } = req.params;
    const configs = datasetConfig.getTemplateConfigs(parseInt(templateId));

    res.json({
      success: true,
      configs: configs
    });
  } catch (error) {
    console.error('Get template datasets error:', error);
    res.status(500).json({ error: error.message || 'Ëé∑ÂèñÈÖçÁΩÆÂ§±Ë¥•' });
  }
});

// Ëé∑ÂèñÊï∞ÊçÆÈõÜÂÆûÈôÖÊï∞ÊçÆÔºàÁî®‰∫éÈ¢ÑËßàÔºâ
app.get('/api/templates/:templateId/cells/:cellId/dataset-data', async (req, res) => {
  try {
    const { templateId, cellId } = req.params;
    const data = await datasetService.executeDatasetQuery(parseInt(templateId), cellId);

    res.json({
      success: true,
      data: data
    });
  } catch (error) {
    console.error('Get dataset data error:', error);
    res.status(500).json({ error: error.message || 'Ëé∑ÂèñÊï∞ÊçÆÂ§±Ë¥•' });
  }
});

// ============ Êï∞ÊçÆÈõÜÁÆ°ÁêÜ API ============

// Ëé∑ÂèñÊâÄÊúâÊï∞ÊçÆÈõÜ
app.get('/api/datasets', async (req, res) => {
  try {
    const datasets = datasetStore.getAllDatasets();
    res.json({
      success: true,
      datasets: datasets
    });
  } catch (error) {
    console.error('Get datasets error:', error);
    res.status(500).json({ error: error.message || 'Ëé∑ÂèñÊï∞ÊçÆÈõÜÂ§±Ë¥•' });
  }
});

// ÂàõÂª∫Êï∞ÊçÆÈõÜ
app.post('/api/datasets', async (req, res) => {
  try {
    const { name, description, type, sqlQuery, fields } = req.body;

    if (!name || !sqlQuery || !fields || fields.length === 0) {
      return res.status(400).json({ error: 'Áº∫Â∞ëÂøÖË¶ÅÂèÇÊï∞' });
    }

    const dataset = datasetStore.addDataset({
      name,
      description,
      type,
      sqlQuery,
      fields
    });

    res.json({
      success: true,
      dataset: dataset
    });
  } catch (error) {
    console.error('Create dataset error:', error);
    res.status(500).json({ error: error.message || 'ÂàõÂª∫Êï∞ÊçÆÈõÜÂ§±Ë¥•' });
  }
});

// Êõ¥Êñ∞Êï∞ÊçÆÈõÜ
app.put('/api/datasets/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;

    const dataset = datasetStore.updateDataset(id, updates);
    if (!dataset) {
      return res.status(404).json({ error: 'Êï∞ÊçÆÈõÜ‰∏çÂ≠òÂú®' });
    }

    res.json({
      success: true,
      dataset: dataset
    });
  } catch (error) {
    console.error('Update dataset error:', error);
    res.status(500).json({ error: error.message || 'Êõ¥Êñ∞Êï∞ÊçÆÈõÜÂ§±Ë¥•' });
  }
});

// Âà†Èô§Êï∞ÊçÆÈõÜ
app.delete('/api/datasets/:id', async (req, res) => {
  try {
    const { id } = req.params;

    const success = datasetStore.deleteDataset(id);
    if (!success) {
      return res.status(404).json({ error: 'Êï∞ÊçÆÈõÜ‰∏çÂ≠òÂú®' });
    }

    res.json({
      success: true,
      message: 'Âà†Èô§ÊàêÂäü'
    });
  } catch (error) {
    console.error('Delete dataset error:', error);
    res.status(500).json({ error: error.message || 'Âà†Èô§Êï∞ÊçÆÈõÜÂ§±Ë¥•' });
  }
});

// È¢ÑËßàÊï∞ÊçÆÈõÜÊï∞ÊçÆ
app.post('/api/datasets/preview', async (req, res) => {
  try {
    const { sqlQuery, type, fields } = req.body;

    if (!sqlQuery) {
      return res.status(400).json({ error: 'Áº∫Â∞ëSQLÊü•ËØ¢' });
    }

    // ÊâßË°åÊü•ËØ¢
    const rows = await prisma.$queryRawUnsafe(sqlQuery);

    const result = {
      type: type || 'list',
      fields: fields || (rows[0] ? Object.keys(rows[0]) : []),
      data: type === 'single' ? rows[0] || {} : rows
    };

    res.json({
      success: true,
      result: result
    });
  } catch (error) {
    console.error('Preview dataset error:', error);
    res.json({
      success: true,
      result: {
        type: 'error',
        message: error.message
      }
    });
  }
});

// ÊâßË°åÊï∞ÊçÆÈõÜÊü•ËØ¢ - ËøûÊé•ÁúüÂÆûPostgreSQLÊï∞ÊçÆÂ∫ì
app.get('/api/datasets/:id/execute', async (req, res) => {
  try {
    const { id } = req.params;

    const dataset = datasetStore.getDataset(id);
    if (!dataset) {
      return res.status(404).json({ error: 'Êï∞ÊçÆÈõÜ‰∏çÂ≠òÂú®' });
    }

    console.log(`üìä ÊâßË°åÊï∞ÊçÆÈõÜÊü•ËØ¢: ${dataset.name} (ID: ${id})`);
    console.log(`SQL: ${dataset.sqlQuery}`);

    let result;

    try {
      // Â∞ùËØïÊâßË°åÁúüÂÆûÊï∞ÊçÆÂ∫ìÊü•ËØ¢
      const rows = await prisma.$queryRawUnsafe(dataset.sqlQuery);
      console.log(`‚úÖ Êü•ËØ¢ÊàêÂäüÔºåËøîÂõû ${rows.length} Êù°ËÆ∞ÂΩï`);

      result = {
        type: dataset.type,
        fields: dataset.fields,
        data: dataset.type === 'single' ? rows[0] || {} : rows,
        source: 'database'
      };
    } catch (dbError) {
      console.warn(`‚ö†Ô∏è Êï∞ÊçÆÂ∫ìÊü•ËØ¢Â§±Ë¥•: ${dbError.message}`);
      console.log('üì¶ ‰ΩøÁî®Ê®°ÊãüÊï∞ÊçÆ‰Ωú‰∏∫Â§áÈÄâ');

      // Â¶ÇÊûúÊï∞ÊçÆÂ∫ìÊü•ËØ¢Â§±Ë¥•Ôºå‰ΩøÁî®Ê®°ÊãüÊï∞ÊçÆ
      const mockData = getMockDataForDataset(dataset);
      result = {
        type: dataset.type,
        fields: dataset.fields,
        data: mockData,
        source: 'mock',
        message: '‰ΩøÁî®Ê®°ÊãüÊï∞ÊçÆÔºàÊï∞ÊçÆÂ∫ìËøûÊé•Â§±Ë¥•Ôºâ'
      };
    }

    res.json({
      success: true,
      result: result
    });
  } catch (error) {
    console.error('Execute dataset error:', error);
    res.json({
      success: true,
      result: {
        type: 'error',
        message: error.message
      }
    });
  }
});

// Ëé∑ÂèñÊï∞ÊçÆÈõÜÁöÑÊ®°ÊãüÊï∞ÊçÆ
function getMockDataForDataset(dataset) {
  // Ê†πÊçÆÊï∞ÊçÆÈõÜÂêçÁß∞ËøîÂõûÁõ∏Â∫îÁöÑÊ®°ÊãüÊï∞ÊçÆ
  const mockDataMap = {
    'Ê®°ÊùøÂàóË°®': [
      { id: 1, name: 'ÂÆâÂÖ®ÂÆ°ËÆ°Êä•ÂëäÊ®°Êùø', createdAt: '2024-01-15', updatedAt: '2024-01-20', status: 'Â∑≤ÂèëÂ∏É' },
      { id: 2, name: 'Êé•Âè£ÂÆâÂÖ®ËØÑ‰º∞Ë°®', createdAt: '2024-01-16', updatedAt: '2024-01-21', status: 'ËçâÁ®ø' },
      { id: 3, name: 'ÊºèÊ¥ûÊâ´ÊèèÊä•Âëä', createdAt: '2024-01-17', updatedAt: '2024-01-22', status: 'Â∑≤ÂèëÂ∏É' }
    ],
    'ÂÆ°ËÆ°Êï∞ÊçÆ': [
      { audit_name: '2024Âπ¥Á¨¨‰∏ÄÂ≠£Â∫¶ÂÆâÂÖ®ÂÆ°ËÆ°', audit_date: '2024-03-31', risk_level: 'È´ò', department: '‰ø°ÊÅØÂÆâÂÖ®ÈÉ®', rectification_status: 'Êï¥Êîπ‰∏≠' },
      { audit_name: 'Êé•Âè£ÂÆâÂÖ®‰∏ìÈ°πÊ£ÄÊü•', audit_date: '2024-03-15', risk_level: '‰∏≠', department: 'ÂºÄÂèëÈÉ®', rectification_status: 'Â∑≤ÂÆåÊàê' },
      { audit_name: 'Êï∞ÊçÆÂ∫ìÊùÉÈôêÂÆ°ËÆ°', audit_date: '2024-03-01', risk_level: '‰Ωé', department: 'ËøêÁª¥ÈÉ®', rectification_status: 'ÂæÖÂ§ÑÁêÜ' }
    ],
    'ÂÆâÂÖ®‰∫ã‰ª∂': [
      { incident_id: 'SEC-2024-001', incident_title: 'SQLÊ≥®ÂÖ•ÊîªÂáª', occurrence_time: '2024-03-20 14:30', incident_type: 'Ê≥®ÂÖ•ÊîªÂáª', severity: 'È´ò' },
      { incident_id: 'SEC-2024-002', incident_title: 'XSSË∑®Á´ôËÑöÊú¨', occurrence_time: '2024-03-21 10:15', incident_type: 'XSSÊîªÂáª', severity: '‰∏≠' },
      { incident_id: 'SEC-2024-003', incident_title: 'Âº±ÂØÜÁ†ÅÂëäË≠¶', occurrence_time: '2024-03-22 09:00', incident_type: 'ËÆ§ËØÅÂÆâÂÖ®', severity: '‰Ωé' }
    ]
  };

  const data = mockDataMap[dataset.name] || [];
  return dataset.type === 'single' ? data[0] || {} : data;
}

// Process template variables (for dynamic export)
app.post('/api/templates/:id/process-variables', async (req, res) => {
  try {
    const templateId = parseInt(req.params.id);
    const { html } = req.body;

    console.log('üîÑ Processing template variables for template:', templateId);

    if (!html) {
      return res.status(400).json({ error: 'HTML content is required' });
    }

    // Create context for variable processing
    const context = {
      currentUser: 'Á≥ªÁªüÁÆ°ÁêÜÂëò',
      department: '‰ø°ÊÅØÂÆâÂÖ®ÂÆ§',
      systemVersion: 'v1.0.0',
      templateId: templateId
    };

    // Process all dynamic variables
    const processedHtml = await variableProcessor.processVariables(html, context);

    console.log('‚úÖ Template variables processed successfully');

    res.json({
      success: true,
      processedHtml: processedHtml
    });

  } catch (error) {
    console.error('Process variables error:', error);
    res.status(500).json({ 
      error: error.message || 'ÂèòÈáèÂ§ÑÁêÜÂ§±Ë¥•'
    });
  }
});

// Initialize
const PORT = process.env.PORT || 3001;

const startServer = async () => {
  try {
    await createDirs();
    await taskScheduler.loadActiveTasks();
    
    app.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
    });
  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
};

startServer();

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('Shutting down gracefully...');
  await prisma.$disconnect();
  process.exit(0);
});